# Defining the default gitlab pre-requisites
default:
  image:
    name: $JFROG_URL/atlas-docker-local/atlas-runner-container-image:v0.1.7
    entrypoint:
      - '/usr/bin/env'
      - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  tags:
    - $RUNNER_TAG

include:
  - project: globetelecom/common-toolchains/pipeline-coe/pipeline-modules
    ref: v1.1.19
    file:
      - Application.gitlab-ci.yml

workflow:
  rules:
    - if: '$CI_COMMIT_TAG'
      variables:
        PE_EVENT_TYPE: "merge"
        ENVIRONMENT: prod
        PE_TARGET_MAIN_ENVIRONMENT: prod
        BRANCH_CONFIG: dev
      when: always
    - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^pr/ && $CI_PIPELINE_SOURCE == "merge_request_event"'
      variables:
        PE_EVENT_TYPE: "merge"
        ENVIRONMENT: prod
        PE_TARGET_MAIN_ENVIRONMENT: prod
        BRANCH_CONFIG: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
        ENVIRONMENT_CONTEXT: "prod"
      when: always
    - if: '$CI_COMMIT_BRANCH =~ /^pr/'
      variables:
        PE_EVENT_TYPE: "commit"
        ENVIRONMENT: prod
        PE_TARGET_MAIN_ENVIRONMENT: prod
        BRANCH_CONFIG: $CI_COMMIT_REF_NAME
        ENVIRONMENT_CONTEXT: "prod"
      when: always
    - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^st/ && $CI_PIPELINE_SOURCE == "merge_request_event"'
      variables:
        PE_EVENT_TYPE: "merge"
        ENVIRONMENT: staging
        PE_TARGET_MAIN_ENVIRONMENT: staging
        BRANCH_CONFIG: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
        ENVIRONMENT_CONTEXT: "nonprod"
      when: always
    - if: '$CI_COMMIT_BRANCH =~ /^st/'
      variables:
        PE_EVENT_TYPE: "commit"
        ENVIRONMENT: staging
        PE_TARGET_MAIN_ENVIRONMENT: staging
        BRANCH_CONFIG: $CI_COMMIT_REF_NAME
        ENVIRONMENT_CONTEXT: "nonprod"
      when: always
    - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^d/ && $CI_PIPELINE_SOURCE == "merge_request_event"'
      variables:
        PE_EVENT_TYPE: "merge"
        ENVIRONMENT: dev
        PE_TARGET_MAIN_ENVIRONMENT: dev
        BRANCH_CONFIG: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
        ENVIRONMENT_CONTEXT: "nonprod"
      when: always
    - if: |
        $CI_COMMIT_BRANCH =~ /^d/ &&
        ($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web")
      variables:
        PE_EVENT_TYPE: "commit"
        ENVIRONMENT: dev
        PE_TARGET_MAIN_ENVIRONMENT: dev
        BRANCH_CONFIG: $CI_COMMIT_REF_NAME
        ENVIRONMENT_CONTEXT: "nonprod"
      when: always
    - when: never

# Stage definition
stages:
  - test
  - build-image
  - prisma
  - publish-image

# New image building image
build-image:
  stage: build-image
  image:
    name: ${PE_ARTIFACTORY_URL}/hmd-docker-virtual/kaniko-project/executor:v1.9.0-debug
    entrypoint: [""]
  before_script:
    - jfrog_docker_auth=$(echo -n "$PE_ARTIFACT_SA_USERNAME:$PE_ARTIFACT_SA_TOKEN" | base64)
    - |
      docker_auth_json='{"auths":{"'"${PE_ARTIFACTORY_URL}"'":{"auth":"'"$(echo "$jfrog_docker_auth" | tr -d '[:space:]')"'"}}}'
      echo "$docker_auth_json" > /kaniko/.docker/config.json
  script:
    - /kaniko/executor
        --context $CI_PROJECT_DIR
        --dockerfile $CI_PROJECT_DIR/Dockerfile
        --use-new-run
        --single-snapshot
        --snapshotMode=time
        --compressed-caching=false
        --build-arg "JFROG_USERNAME=$PE_ARTIFACT_SA_USERNAME"
        --build-arg "JFROG_PASSWORD=$PE_ARTIFACT_SA_TOKEN"
        --build-arg "ARTIFACTORY_URL=$PE_ARTIFACTORY_URL"
        --tarPath ${CI_PROJECT_DIR}/app_image.tar
        --destination ${PE_ARTIFACTORY_URL}/${PE_ARTIFACT_DOCKER_LOCAL_REPO}/${CI_PROJECT_NAME}:${CI_COMMIT_TAG}
        --no-push
  artifacts:
    paths:
      - ${CI_PROJECT_DIR}/app_image.tar
    when: always

# Prisma Scanning
prisma:
  stage: prisma
  variables:
    IMAGE_TAR: app_image.tar
  extends: .app-scan:prisma-image-pe-updated-vars
  needs: ["build-image"]

# Image publish stage (automatic on tags, manual otherwise)
.publish-image-base:
  stage: publish-image
  extends: .docker-publish-by-env:jfrog-updated-cicd
  needs: ["build-image", "prisma"]

publish-image:
  extends: .publish-image-base
  except:
    - tags
  when: manual

publish-image:on-tag:
  extends: .publish-image-base
  only:
    - tags
  when: on_success

# ------------------------------------------------------------------
# Probe the downstream API to surface the exact error (403/404/400)
# ------------------------------------------------------------------
downstream-probe:
  stage: publish-image
  rules:
    - if: '$CI_COMMIT_TAG'        # run on tag pipelines
  image: alpine:3.20
  before_script:
    - apk add --no-cache curl jq
  script:
    - set -eu
    - DOWNSTREAM_PATH="globetelecom/platforms/reloads-service/testing/dodrio-test-tools"
    - REF="main"   # target ref in Repo B
    - DS_ENC="$(printf '%s' "$DOWNSTREAM_PATH" | jq -sRr @uri)"
    - echo "Probing downstream $DOWNSTREAM_PATH encoded $DS_ENC) ref=$REF"
    - |
      curl -sS -D /tmp/h -o /tmp/b \
        -X POST -H "PRIVATE-TOKEN: $PE_JOB_TOKEN" \
        --data-urlencode ref="$REF" \
        "$CI_API_V4_URL/projects/$DS_ENC/pipeline" || true
    - echo "----- HTTP response headers -----"; sed -n '1,80p' /tmp/h || true
    - echo "----- Response body -----"; cat /tmp/b || true
  allow_failure: true

# ------------------------------------------------------------------
# Multi-project trigger (fires when a new TAG is pushed in Repo A)
# ------------------------------------------------------------------
trigger-downstream-on-tag:
  stage: publish-image
  needs: ["downstream-probe"]
  rules:
    - if: '$CI_COMMIT_TAG'      # only on tag pipelines in Repo A
  trigger:
    project: globetelecom/platforms/reloads-service/testing/dodrio-test-tools
    branch: main
    forward:
      pipeline_variables: true
  variables:
    UPSTREAM_TAG: "$CI_COMMIT_TAG"
    UPSTREAM_PROJECT: "$CI_PROJECT_PATH"
    UPSTREAM_SHA: "$CI_COMMIT_SHA"

tag-on-dev-merge:
  stage: publish-image
  image: alpine:3.20
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && ($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "merge_request_event")'
      when: always
  before_script:
    - apk add --no-cache git curl jq
  script:
    - echo "Fetching all tags..."
    - git fetch --tags

    - |
      TAG_PATTERN='^v[0-9]+\.[0-9]+\.[0-9]+-dev$'
      echo 'Looking for latest matching dev tag...'
      latest_tag=$(git tag --list | grep -E "$TAG_PATTERN" | sort -V | tail -n 1)
      echo "Latest dev tag: $latest_tag"

      if [ -z "$latest_tag" ]; then
        new_tag="v0.1.0-dev"
      else
        major=$(echo "$latest_tag" | awk -F'[v.-]' '{print $2}')
        minor=$(echo "$latest_tag" | awk -F'[v.-]' '{print $3}')
        patch=$(echo "$latest_tag" | awk -F'[v.-]' '{print $4}')
        patch=$((patch + 1))
        new_tag="v${major}.${minor}.${patch}-dev"
      fi

      echo "Creating and pushing new tag: $new_tag"
      curl --request POST --header "PRIVATE-TOKEN: ${PE_JOB_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "{ \"tag_name\": \"$new_tag\", \"ref\": \"$CI_COMMIT_SHA\" }" \
        "$CI_API_V4_URL/projects/${CI_PROJECT_ID}/repository/tags"

